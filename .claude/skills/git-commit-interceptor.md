---
skill-name: git-commit-interceptor
priority: 0
trigger: |
  Activate when the user's request involves git commits:
  - "commit", "git commit"
  - "stage and commit", "add and commit"
  - "save the changes", "save changes"
  - "create a commit", "make a commit"
  - "push the changes" (implies commit first)
  - "check in", "checkin"
  - Any mention of commit messages
  - Any git workflow that ends in committing
allowed-tools:
  - Read
  - Grep
  - Glob
  - Bash
  - TodoWrite
  - Skill
  - Task
  - mcp__atlassian__*
forbidden-tools:
  - Edit
  - Write
  - NotebookEdit
description: |
  Intercepts git commit requests and routes them through the git-commit-helper agent.
  Ensures all commits follow conventional commit format and project standards.
  Priority 0 runs alongside code-change-interceptor.
---

# Git Commit Interceptor

## Purpose

This skill ensures that ALL git commits in the main orchestrator thread are routed through the `git-commit-helper` agent. This guarantees:

1. Conventional commit format
2. Jira linking
3. No AI attribution (FORBIDDEN patterns)
4. Semantic-release compatibility

## Detection Patterns

### Direct Commit Requests

- "commit", "git commit", "create commit"
- "make a commit", "commit the changes"
- "stage and commit", "add and commit"

### Implicit Commit Requests

- "save the changes", "save my work"
- "check in the code", "checkin"
- "push to git" (implies commit first)
- "finish this feature" (may imply commit)

### Git Workflow Context

- After code changes are complete
- After tests pass
- Before PR creation

## Response Pattern

### When Commit is Requested

**User:** "Commit these changes" / "git commit" / etc.

**Response:**

```markdown
I'll create a commit through the git-commit-helper agent to ensure proper conventional commit format.

Invoking /commit...
```

Then invoke:

```
Skill(skill="commit")
```

### Alternative via Task Tool

```
Task(
  subagent_type="git-commit-helper",
  prompt="""
  Analyze staged changes and create a conventional commit.

  Requirements:
  1. Run git status and git diff --staged
  2. Determine commit type (feat, fix, perf, docs, style, refactor, test, chore)
  3. Identify scope from affected files
  4. Generate commit message following Angular format
  5. Include Jira reference if available
  6. VERIFY no forbidden patterns (AI attribution)
  7. Execute commit using heredoc format
  """,
  description="Create git commit"
)
```

## FORBIDDEN in Orchestrator Thread

```bash
# NEVER run these directly:
git commit -m "..."
git commit -am "..."
git commit --amend
```

**ALWAYS delegate to git-commit-helper agent.**

## Commit Format Reminder

The git-commit-helper will create commits in this format:

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:** feat, fix, perf, docs, style, refactor, test, chore

**Attribution:** Default attribution is disabled via `.claude/settings.json`. The agent validates against fallback patterns (`claude.ai`, `anthropic.com`, `Generated by AI`).

## Edge Cases

### User Wants to Amend

**User:** "Amend the last commit"

**Response:**

```markdown
Amending commits requires careful consideration. The git-commit-helper agent will:
1. Check if the last commit is yours (not AI-attributed)
2. Verify the commit hasn't been pushed
3. Perform the amend if safe

Invoking /commit with amend context...
```

### User Wants Multiple Commits

**User:** "Create separate commits for each file"

**Response:**

```markdown
I'll invoke the git-commit-helper to create atomic commits for each logical change.

The agent will:
1. Analyze staged files
2. Group by logical change
3. Create separate commits for each group
4. Use conventional format for each

Invoking /commit...
```

### User Provides Commit Message

**User:** "Commit with message 'fix: resolve login bug'"

**Response:**

```markdown
I'll pass your message to the git-commit-helper for validation and commit creation.

The agent will:
1. Validate the message format
2. Check for forbidden patterns
3. Add Jira reference if missing
4. Execute the commit

Invoking /commit...
```

## Integration Flow

```
User: "commit" / "save changes" / etc.
       |
       v
[git-commit-interceptor skill activates]
       |
       v
Orchestrator: Invokes Skill(skill="commit")
       |
       v
[git-commit-helper agent spawned]
       |
       v
Agent: Analyzes, formats, commits
       |
       v
Result: Clean conventional commit
```

## Why This Matters

1. **Consistency**: Every commit follows the same format
2. **Compliance**: No AI attribution leakage
3. **Automation**: Semantic-release can parse commits
4. **Traceability**: Jira links in all commits
5. **Quality**: Agent validates before committing

## Agent Spawning Authority (CRASH PREVENTION)

**WARNING**: The Task tool is ORCHESTRATOR-ONLY. Nested Task() calls (agent spawning agent) cause Claude Code to CRASH.

### How Skill(skill="commit") Actually Works

**IMPORTANT**: The Skill tool does NOT "route through main thread". It loads the command content **inline** into the calling agent's context. The command instructions then execute in that agent's context.

This means:
- When **main thread** calls `Skill(skill="commit")`: Command tells it to spawn git-commit-helper via Task - WORKS
- When **subagent** calls `Skill(skill="commit")`: Command detects subagent context and provides direct commit instructions - SAFE

The `/commit` skill (`.claude/skills/commit/SKILL.md`) has **context detection** that provides different instructions based on caller:
- **Main thread path**: Spawn git-commit-helper via Task
- **Subagent path**: Execute commit directly without spawning

### For SUBAGENTS (dev agents, QA agents, advisory agents)

`Skill(skill="commit")` is SAFE because the command detects subagent context and:
1. Does NOT instruct to use Task()
2. Provides direct commit execution steps
3. Validates format and forbidden patterns inline

### For MAIN THREAD (orchestrator)

`Skill(skill="commit")` spawns git-commit-helper via Task (normal flow).

**See `.claude/rules/agent-spawning-rules.md` for complete rules.**
