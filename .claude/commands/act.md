---
description: Execute the current plan - creates Jira tasks, assigns to sprint, and starts parallel agent implementation
---

## CRITICAL: Orchestrator Delegation Required

**The orchestrator MUST NOT execute plans directly.**

When `/act` is invoked, the orchestrator MUST:

1. Use Task tool to spawn project-manager agent:
```
Task(
  subagent_type="project-manager",
  prompt="Execute the current plan. Create Jira tasks (if not already created), assign to active sprint, create worktrees for independent tasks, and launch parallel implementation agents. Monitor progress and coordinate QA/review when complete.",
  description="Execute plan via /act"
)
```

2. Wait for agent to complete or provide status updates
3. Report execution status to user

**FORBIDDEN in orchestrator thread:**
- Creating Jira tasks directly
- Launching implementation agents directly
- Creating worktrees directly
- Editing code files

**The orchestrator may only:**
- Invoke the project-manager agent via Task tool
- Monitor and report on agent progress
- Provide context from the current plan

---

# /act Command

Execute the current plan by creating Jira tasks (if not already created), assigning them to the active sprint, and starting parallel agent implementation via worktrees.

## Prerequisites

Before running `/act`:
1. You should be in plan mode (shift+tab) or have just completed planning
2. Plan confidence should be at least 80%
3. Plan should include clear tasks with acceptance criteria
4. **MANDATORY: Plan artifacts must exist (see Phase 0 below)**

## MANDATORY: Phase 0 - Plan Artifact Verification (HARD BLOCKER)

**This phase runs FIRST, BEFORE any other phase. It is enforced by the `plan-prerequisites-enforcement` skill (priority -3).**

Before creating Jira tasks or starting implementation, verify required planning artifacts exist.

### Step 0.1: Identify the Current Plan

```bash
# Search for plan directories
Glob("docs/plan/PLAN-*")
Glob("docs/plan/*-*-*")

# Check conversation context for plan ID
# Check most recent plan state file
```

If no plan is identified:
```markdown
## No Plan Found

Cannot execute `/act` without a plan.

**To Create a Plan:**
1. Enter plan mode (shift+tab)
2. Describe what you want to build
3. Wait for system-architect to create technical-plan.md
4. For complex plans (3+ tasks), wait for:
   - staff-engineer-advisor to create pseudo-code-plan.md
   - technical-spec.md and critical-constraints.md to be generated
5. Then run `/act`

**For Quick Changes:**
Use `/quick-plan {description}` for simple changes.
```

### Step 0.2: Verify Required Artifacts

**Plan Directory:** `docs/plan/{plan-id}/`

**Check for REQUIRED artifacts:**

```bash
# Always required
Read("docs/plan/{plan-id}/technical-plan.md")

# Required for complex plans (3+ tasks)
Read("docs/plan/{plan-id}/pseudo-code-plan.md")
Read("docs/plan/{plan-id}/technical-spec.md")
Read("docs/plan/{plan-id}/critical-constraints.md")
```

### Step 0.3: Report Verification Results

**If ALL artifacts exist:**

```markdown
## Plan Artifact Verification: PASSED

**Plan:** {plan-id}
**Location:** docs/plan/{plan-id}/

| Artifact | Status |
|----------|--------|
| technical-plan.md | FOUND |
| pseudo-code-plan.md | FOUND |
| technical-spec.md | FOUND |
| critical-constraints.md | FOUND |

Proceeding with implementation...
```

**If ANY artifact is MISSING:**

```markdown
## Plan Artifact Verification: FAILED

**Plan:** {plan-id}
**Location:** docs/plan/{plan-id}/

### Missing Required Artifacts

| Artifact | Status | How to Create |
|----------|--------|---------------|
| technical-plan.md | MISSING | system-architect creates in plan mode |
| pseudo-code-plan.md | MISSING | staff-engineer-advisor creates in plan mode |
| technical-spec.md | MISSING | system-architect generates after plan review |
| critical-constraints.md | MISSING | system-architect generates after plan review |

### BLOCKED: Cannot Proceed

The planning workflow requires these artifacts before implementation:
1. **technical-plan.md** - Created by system-architect (architecture, tasks, dependencies)
2. **pseudo-code-plan.md** - Created by staff-engineer-advisor (implementation approach)
3. **technical-spec.md** - Generated by system-architect (file/API/DB changes)
4. **critical-constraints.md** - Generated by system-architect (MUST DO/MUST NOT/PRESERVE)

**To Resolve:**
1. Enter plan mode (shift+tab)
2. Request: "Complete planning for {plan-id}" or start a new plan
3. Wait for all artifacts to be created
4. Then run `/act`

**To Override (NOT RECOMMENDED):**
Type "proceed without planning" to skip artifact verification.
This may lead to implementation issues and rework.

**Alternative for Simple Changes:**
Use `/quick-plan {description}` which only requires technical-plan.md.
```

### Step 0.4: Handle Overrides

**User types "proceed without planning":**

```markdown
## Override Accepted

**WARNING:** Proceeding without required planning artifacts.

Risks:
- Implementation may miss critical requirements
- No pseudo-code guidance for developers
- Critical constraints may be violated
- Increased likelihood of rework

Proceeding with implementation at your own risk...
```

### Step 0.5: Handle Quick Plan Bypass

If the plan was created via `/quick-plan` (marker: `docs/plan/{plan-id}/.quick-plan` exists):
- Only require `technical-plan.md`
- Skip pseudo-code-plan.md, technical-spec.md, critical-constraints.md checks
- Note in output: "Quick plan mode - simplified artifact requirements"

## MANDATORY: Confidence Display

**Before executing ANY phase of `/act`, you MUST display the current plan confidence prominently:**

```markdown
## Pre-Implementation Confidence Check

**Plan Confidence: XX%** [STATUS]

| Status | Meaning |
|--------|---------|
| [HIGH CONFIDENCE] 90-100% | Excellent - proceed with confidence |
| [GOOD CONFIDENCE] 80-89% | Good - proceed with implementation |
| [MODERATE CONFIDENCE] 60-79% | Warning - consider more planning |
| [LOW CONFIDENCE] <60% | Block - do not proceed |
```

### Confidence Gate Enforcement

**If confidence < 80%:**
```markdown
## Confidence Below Threshold

**Current Confidence: XX%** [MODERATE/LOW CONFIDENCE]

The plan confidence is below the 80% threshold required for `/act`.

**Options:**
1. Continue planning to address gaps and increase confidence
2. Run `/create-plan-in-jira` to create tasks for review (60% minimum)
3. Override and proceed anyway (type "proceed anyway" to confirm)

What would you like to do?
```

**If confidence >= 80%:**
```markdown
## Confidence Check Passed

**Plan Confidence: XX%** [GOOD/HIGH CONFIDENCE]

Proceeding with implementation...
```

## Workflow

### Phase 1: Detect Existing Jira Keys in Plan

**CRITICAL**: Before creating any tasks, scan the current plan for existing Jira keys.

**Detection Pattern:**
```
# Regex patterns to find Jira keys in plan
/AI-\d+/g
/\[AI-\d+\]/g
```

**If Jira keys found in the plan:**
1. Extract all unique Jira keys (e.g., AI-123, AI-124, AI-125)
2. Verify they exist in Jira:
   ```
   jira_get_issue(issueKey="AI-123")
   ```
3. **USE EXISTING TASKS** - Do NOT create duplicates
4. Skip to Phase 2 (Get User Context)

**If NO Jira keys found:**
1. Check for tasks matching plan keywords (legacy behavior)
2. Create new tasks from plan content

### Phase 1.5: MANDATORY Pre-Launch Validation (HARD BLOCKER)

**CRITICAL: This phase MUST complete successfully BEFORE launching any background agents.**

Before creating worktrees or dispatching ANY implementation agent, you MUST validate EVERY task against Jira. This ensures sprint discipline and proper task tracking.

**Validation Steps (for EACH task):**

1. **Get Current User** (once at start):
   ```
   jira_get_user_info()
   -> Extract accountId
   ```

2. **Get Active Sprint** (once at start):
   ```
   jira_get_sprints(boardId=1, state="active")
   -> Extract active sprint id
   ```

3. **Validate Each Task**:
   ```
   jira_get_issue(
     issueKey="AI-XXX",
     fields=["status", "assignee", "customfield_10020", "summary"]
   )
   ```

4. **Check Validation Criteria**:
   | Check | Pass Condition | Failure Action |
   |-------|----------------|----------------|
   | Task Exists | API returns 200 | ABORT - task must exist |
   | Assignee | `assignee.accountId == currentUser.accountId` | AUTO-FIX or ABORT |
   | Sprint | Active sprint ID in `customfield_10020` | AUTO-FIX or ABORT |

5. **Report Validation Results**:
   ```markdown
   ## Pre-Launch Validation Results

   | Task | Exists | Assigned | In Sprint | Status |
   |------|--------|----------|-----------|--------|
   | AI-456 | PASS | PASS | PASS | READY |
   | AI-457 | PASS | FAIL->FIXED | FAIL->FIXED | READY |

   All tasks validated. Proceeding with agent launch...
   ```

**Auto-Fix Allowed:**
- If task not assigned: Assign to current user
- If task not in sprint: Move to active sprint

**Auto-Fix Process:**
```
jira_edit_issue(issueKey="AI-XXX", fields={"assignee": {"accountId": "{user_id}"}})
jira_move_issues_to_sprint(sprintId={active_sprint_id}, issueKeys=["AI-XXX"])
```

**ABORT Conditions (Cannot Auto-Fix):**
- Task does not exist in Jira
- Task is assigned to a different user (requires manual reassignment)
- Jira API errors prevent validation

**If ANY task fails validation and cannot be auto-fixed:**
```markdown
## Pre-Launch Validation: FAILED

| Task | Issue | Resolution |
|------|-------|------------|
| AI-456 | Not found | Create task first |
| AI-457 | Assigned to John Doe | Manual reassignment required |

**WORKFLOW ABORTED**: Cannot proceed until all tasks pass validation.

Please fix the issues above and run /act again.
```

**NEVER skip this phase. NEVER launch agents without validation passing.**

---

### Phase 1b: Legacy Duplicate Check (No Keys Found)

Only if no Jira keys were detected in the plan:

```
# Search Jira for potential duplicates
jira_search_jql(
  jql="project = AI AND summary ~ '{plan keywords}' AND created >= -7d",
  fields=["key", "summary", "status"]
)
```

If matching tasks found:
- Display them to user
- Ask: "Found existing tasks. Should I use these or create new ones?"

### Phase 2: Get User Context

```
# Get authenticated user for task assignment
jira_get_user_info()

# Get active sprint for the default board (board ID: 1)
jira_get_sprints(boardId=1, state="active")
```

### Phase 3: Create Jira Tasks (if needed)

For each task identified in the plan:

1. **Create the task:**
```
jira_create_issue(
  projectKey="AI",
  issueTypeName="Task",  # or Story/Subtask as appropriate
  summary="{task summary}",
  description="## Summary\n{description}\n\n## Acceptance Criteria\n{criteria}\n\n## Agent Routing\n- Implement: {agent}\n\n## Plan Reference\n{plan identifier}"
)
```

2. **Move to active sprint:**
```
jira_move_issues_to_sprint(
  sprintId={active_sprint_id},
  issueKeys=["{task_key}"]
)
```

3. **Assign to current user:**
```
jira_edit_issue(
  issueKey="{task_key}",
  fields={"assignee": {"accountId": "{user_account_id}"}}
)
```

### Phase 4: Determine Agent Routing

Based on task characteristics, route to appropriate agents:

| File Patterns | Agent |
|---------------|-------|
| `*.cs`, `Controllers/*`, `Services/*`, `Repositories/*` | backend-developer |
| `*.tsx`, `*.ts`, `components/*`, `app/*` | frontend-developer |
| `*.md` (in docs/) | technical-writer |
| Mixed backend + frontend | Create separate tasks for each |

### Phase 5: Parallel Execution via Worktrees (Just-In-Time)

**DEPENDENCY MERGE GATE (ABSOLUTE):** A task's worktree is ONLY created after ALL tasks it depends on are:
1. Implementation complete
2. QA passed
3. **MERGED into active branch** (not just complete - MERGED)

This prevents tasks from starting with stale code.

For tasks with no unmet dependencies (all deps MERGED, max 8 concurrent):

1. **Create worktrees:**
```bash
/development/ai-it-for-msps/scripts/worktree-create.sh {JIRA_KEY}
```

2. **Add Jira labels:**
```
jira_edit_issue(
  issueKey="{JIRA_KEY}",
  fields={"labels": ["worktree-active"]}
)
```

3. **Launch background agents:**
```
Task(
  description: "Implement {JIRA_KEY}: {summary}",
  prompt: "
    WORKTREE TASK ASSIGNMENT
    ========================
    Jira Task:      {JIRA_KEY}
    Worktree Path:  {worktree_path}
    Branch:         {branch_name}
    Base Branch:    {base_branch}

    CRITICAL: All file operations MUST be in the worktree path above.

    ============================================================
    USER REQUIREMENTS (WORD OF GOD - READ FIRST)
    ============================================================
    Before ANYTHING else, you MUST:

    1. Read USER REQUIREMENTS (CRITICAL - DO THIS FIRST):
       docs/plan/{plan-id}/user-requirements.md

    2. Find requirements assigned to YOUR Jira task (check "Jira Task(s)" column)

    3. Post USER REQUIREMENTS ACKNOWLEDGMENT to Jira (REQUIRED before coding):
       'USER REQUIREMENTS ACKNOWLEDGMENT:
       I have read docs/plan/{plan-id}/user-requirements.md.

       Requirements assigned to this task:
       | Req ID | Verbatim User Quote (first 50 chars) | Status |
       |--------|--------------------------------------|--------|
       | UR-X | "{user's exact words}..." | UNDERSTOOD - Will implement EXACTLY |

       COMMITMENT: I will implement these VERBATIM.
       If I cannot satisfy ANY requirement exactly, I will STOP and add
       label `requirement-blocked` before proceeding.'

    User requirements are WORD OF GOD. Implementation MUST match verbatim.
    ============================================================

    ============================================================
    TECHNICAL SPECIFICATION (HARD BLOCKER)
    ============================================================
    After reading user requirements, you MUST:

    1. Read FULL technical specification:
       docs/plan/{plan-id}/technical-spec.md

    2. Read and acknowledge constraints:
       docs/plan/{plan-id}/critical-constraints.md

    3. Post CONSTRAINT ACKNOWLEDGMENT to Jira (REQUIRED before proceeding):
       'CONSTRAINT ACKNOWLEDGMENT:
       - MUST DO [1]: {constraint} - UNDERSTOOD
       - MUST DO [2]: {constraint} - UNDERSTOOD
       - MUST NOT [1]: {constraint} - UNDERSTOOD
       - MUST NOT [2]: {constraint} - UNDERSTOOD
       - PRESERVE [1]: {resource} - UNDERSTOOD'

    4. After implementation, post verification to Jira:
       'CONSTRAINT VERIFICATION:
       - MUST DO [1]: COMPLETED
       - MUST DO [2]: COMPLETED
       - MUST NOT [1]: VERIFIED
       - MUST NOT [2]: VERIFIED
       - PRESERVE [1]: INTACT'

    IMPLEMENTATION IS BLOCKED until both acknowledgments are posted to Jira.
    ============================================================

    ============================================================
    TEST-DRIVEN DEVELOPMENT (TDD) REQUIREMENTS
    ============================================================

    TDD is MANDATORY for critical paths. Follow Red-Green-Refactor:

    **TDD REQUIRED Categories (MUST write test FIRST):**
    | Category | Example Files |
    |----------|---------------|
    | Security/Auth | JWT validation, role checks |
    | Company Isolation | Repository filtering by company_uuid |
    | Business Logic | *Service.cs, *Handler.cs |
    | Bug Fixes | Any fix: commit |
    | Repositories | *Repository.cs |
    | Logic Hooks (Frontend) | *.logic.ts |

    **TDD OPTIONAL Categories (test after is acceptable):**
    | Category | Example Files |
    |----------|---------------|
    | Simple DTOs | *Dto.cs, *Request.cs, *Response.cs |
    | Thin Controllers | *Controller.cs (delegates to services) |
    | UI Components | *.tsx (atoms, molecules) |
    | Styling | *.module.scss, *.css |

    **TDD Commit Sequence (for required categories):**
    1. Commit failing test: 'test: add test for X'
    2. Commit implementation: 'feat: implement X to pass tests'
    3. Commit refactor (if needed): 'refactor: improve X'

    **Bug Fix Pattern (MANDATORY):**
    1. Write test that reproduces the bug (proves it exists)
    2. Commit: 'test: add failing test for bug (AI-XXX)'
    3. Write fix that makes test pass
    4. Commit: 'fix: resolve issue description (AI-XXX)'

    QA will verify TDD compliance via git history. Violations on
    critical paths will result in BLOCKED status with tdd-violation label.
    ============================================================

    TASK REQUIREMENTS:
    {task description from Jira}

    WORKFLOW:
    1. Transition Jira to 'In Progress'
    2. Read technical spec and constraints (if exists - HARD BLOCKER)
    3. Post constraint acknowledgment to Jira (if spec exists - HARD BLOCKER)
    4. Verify working directory (pwd, git branch)
    5. Determine if task touches TDD-required categories
    6. If TDD required: Write failing test FIRST, commit, then implement
    7. If TDD optional: Implement, then write tests
    8. Use @agent-git-commit-helper for small, frequent commits
    9. Post constraint verification to Jira (if spec existed)
    10. Update Jira on completion

    Report: TASK_COMPLETE or TASK_BLOCKED with reason.
  ",
  subagent_type="{appropriate_agent}",
  run_in_background=true
)
```

### Phase 6: Monitor and Coordinate

Track all running agents:
```
ACTIVE_AGENTS = {
  "AI-XXX": { agent_id: "abc123", worktree: "...", status: "running" },
  ...
}
```

Periodically check:
```
TaskOutput(agent_id: "{id}")
```

When agents complete:
1. Update Jira labels: `worktree-active` -> `worktree-qa-pending`
2. Transition Jira to "Review" status
3. Trigger QA if appropriate

### Phase 7: Code Review (END OF PLAN - Single PR)

**CRITICAL**: Code review happens ONCE at the END of the plan, after ALL tasks are complete and ALL QA has passed.

After all implementation and QA complete:
```
/review-code {PLAN_IDENTIFIER}
```

This creates a SINGLE PR for the entire plan. **NEVER auto-merge** - PR requires human approval.

## Execution Flow

```
/act
  |
  +-> Check for existing Jira tasks (idempotency)
  |
  +-> Get user context (account ID, active sprint)
  |
  +-> Create Jira tasks (if needed)
  |     |
  |     +-> Move to active sprint
  |     +-> Assign to current user
  |
  +-> Create worktrees just-in-time (only for ready tasks)
  |
  +-> Launch background agents (max 8 parallel, dependency-based)
  |
  +-> Monitor progress
  |
  +-> Coordinate QA and review when complete
```

## Example Usage

**After planning a feature:**
```
User: /act
Claude: I'll execute the current plan.

Checking for existing Jira tasks...
No duplicates found.

Getting user context...
- User: john.doe@example.com
- Active Sprint: Sprint 15 (ID: 101)

Creating Jira tasks:
1. AI-456: Add pagination to users API (backend-developer)
2. AI-457: Add pagination UI controls (frontend-developer)

Moving to active sprint...
Assigning to you...

Creating worktrees...
- /development/ai-it-for-msps.worktrees/AI-456-a3f2
- /development/ai-it-for-msps.worktrees/AI-457-b7c9

Launching parallel agents...
- backend-developer for AI-456 [agent_id: abc123]
- frontend-developer for AI-457 [agent_id: def456]

## Execution Status

| Task | Agent | Status | Worktree |
|------|-------|--------|----------|
| AI-456 | backend-developer | running | AI-456-a3f2 |
| AI-457 | frontend-developer | running | AI-457-b7c9 |

**Active Agents**: 2/5
**Active Worktrees**: 2/10

I'll monitor progress. Run `/act status` to check on agents.
```

## Subcommands

### `/act status`
Show current agent execution status without launching new tasks.

### `/act continue`
Resume monitoring after a break. Check agent status and proceed with next steps.

## Advisory Agent Consultation

When tasks involve specific domains, consult advisory agents before implementation:

| Domain Keywords | Advisory Agent |
|-----------------|----------------|
| azure openai, prompt, ai, llm | ai-prompt-advisor |
| authentication, security, encryption | security-engineer-advisor |
| grpc, websocket, network | network-engineer-advisor |
| database, postgresql, query, index | database-advisor |
| docker, kubernetes, deployment | devops-engineer |
| architecture, scalability, critical | staff-engineer-advisor |

## Error Handling

### Duplicate Task Detection
If Jira tasks matching the plan already exist:
1. Display existing tasks
2. Ask user whether to use existing or create new
3. If using existing, skip creation phase

### Agent Failure
If an agent reports `TASK_BLOCKED`:
1. Read the blocking reason
2. Add Jira comment with error details
3. Add `blocked` label
4. Ask user for guidance or assign to staff-engineer-advisor

### Merge Conflicts
If worktree merge fails:
1. Keep `worktree-merging` label (lock)
2. Invoke staff-engineer-advisor for resolution
3. After resolution, continue merge

## Remember

- **Idempotency**: Running `/act` multiple times should not create duplicate tasks
- **Confidence Gate**: Warn if plan confidence is below 80%
- **Parallel Execution**: Independent tasks run simultaneously (max 5)
- **Worktree Rules**: Follow all rules in `.claude/rules/worktree-rules.md`
- **Commit Rules**: All agents use `/commit` for proper conventional commits
